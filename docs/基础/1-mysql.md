## 1. Mysql的存储引擎,MyISAM和InnoDB的区别。 
### 1. 存储结构

- MyISAM：每个MyISAM在磁盘上存储成三个文件（结构、表索引、表数据空间）。*.frm*文件存储表定义，*.MYD (MYData)*存储表的数据，.MYI (MYIndex)存储索引。
- InnoDB：默认情况下所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

### 2. 存储空间

- MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
- InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

### 3. 可移植性、备份及恢复

- MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
- InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。

### 4. 事务支持

- MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
- InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

### 5. AUTO_INCREMENT

- MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
- InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

### 6. 表锁差异

- MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
- InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

### 7. 全文索引

- MyISAM：支持 FULLTEXT类型的全文索引
- InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。

### 8. 表主键

- MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
- InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。

### 9. 表的具体行数

- MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。
- InnoDB：没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。

### 10. CURD操作

- MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。
- InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。

### 11. 外键

- MyISAM：不支持
- InnoDB：支持


## 2. delete drop truncate区别

- truncate 和 delete只删除数据，不删除表结构 ,drop删除表结构，并且释放所占的空间。
- 删除数据的速度，一般来说: drop> truncate > delete
- delete属于DML语言，需要事务管理，commit之后才能生效。drop和truncate属于DDL语言，操作立刻生效，不可回滚

**使用场合**：
  1.当你不再需要该表时， 用drop;
  2.当你仍要保留该表，但要删除所有记录时， 用truncate;
  3.当你要删除部分记录时（always with a where clause), 用 delete.

> 对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器



## 3.SQL语句主要分为哪几类

- 数据定义语言`DDL（Data Definition Language）`：主要有`CREATE，DROP，ALTER`等对逻辑结构有操作的，包括表结构、视图和索引。
- 数据库查询语言`DQL（Data Query Language）`：主要以`SELECT`为主
- 数据操纵语言`DML（Data Manipulation Language）`：主要包括`INSERT，UPDATE，DELETE`
- 数据控制功能`DCL（Data Control Language）`：主要是权限控制能操作，包括`GRANT，REVOKE，COMMIT，ROLLBACK`等。



## 4. CHAR和VARCHAR的区别

### 4.1 存储方式

- 当值存储在CHAR字段中时，<font color='red'>剩余的字符将用空格填充;</font>

> 例如，一个字段是 name char(5)，并且您要存储只是"tom"，则实际值将存储为"tom  "

- 与CHAR不同，VARCHAR只占用基于存储的数据的空间
- varchar类型的实际长度是它的值的实际长度+1，这一个(也可能是两)字节用于保存实际使用了多大的长度
- char的存储方式是：英文字符占1个字节，汉字占用2个字节；varchar的存储方式是：英文和汉字都占用2个字节，两者的存储数据都非unicode的字符数据

### 4.2 数据检索

- 如果CHAR字段的数据较短时，会经过空格填充，所以查询出来的结果需删除尾随空格。

### 4.3 存储上限

- char(n)，n最大255。
- varchar(n)，n最大65535，另外，按照字符集，不能超过65525字节。这65535字节不能全用来存数据，因为有1-2字节要用来存占用长度，255字节以下用1字节存储长度，255字节以上用2字节存储长度。
- text，上限65535字节，再多也能存，因为还有mediumtext上限2^24-3字节大概16m，longtext上限2^32-4字节大概4G。


### 4.4 性能对比

> 按照查询速度： char最快， varchar次之，text最慢

- char，定长，基本没有碎片，索引速度极快。
- varchar，不定长，索引速度没有char快。理论上可以添加全部索引，但是数据长度太大时索引也会截取数据前面的一部分。
- text，不定长，速度慢，索引只能是前缀索引。


### 4.5 不同存储引擎对 CHAR 和 VARCHAR 的使用

- MyISAM 存储引擎:建议使用固定长度的数据列代替可变长度的数据列。

- MEMORY 存储引擎:目前都使用固定长度的数据行存储，因此无论使用 CHAR 或 VARCHAR 列都没有关系。两者都是作为 CHAR 类型处理。
- InnoDB 存储引擎:建议使用 VARCHAR 类型。对于 InnoDB 数据表，内部的行存储格式没有区分固定长度和可变长度列(所有数据行都使用指向数据列值的头指针)，因此在 本质上，使用固定长度的 CHAR 列不一定比使用可变长度 VARCHAR 列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于 CHAR 平均占用的空间多于 VARCHAR，因此使 用 VARCHAR 来最小化需要处理的数据行的存储总量和磁盘 I/O 是比较好的。



## 5. insert 和 replace的区别

replace into 跟 insert 功能类似，不同点在于：replace into 首先尝试插入数据到表中， 1. 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。

> <font color='red'>要注意的是：插入数据的表必须有主键或者是唯一索引！否则的话，replace into 会直接插入数据，这将导致表中出现重复的数据。</font>


- **MySQL replace into 有三种形式：**

```sql
replace into tbl_name(col_name, ...) values(...)

replace into tbl_name(col_name, ...) select ...

replace into tbl_name set col_name=value, ...
```

>前两种形式用的多些。其中 "into” 关键字可以省略，不过最好加上 "into”，这样意思更加直观。另外，对于那些没有给予值的列，MySQL 将自动为这些列赋上默认值



## 6. 表设计三大范式

- 1．第一范式(原子性):所有字段值都是不可分解的原子值       
- 2．第二范式(在第一范式的基础上):确保表中的每列都和主键相关，即一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中
- 3．第三范式(在第二范式的基础上):确保每列都和主键列直接关联,而不是间接相关



## 7. 数据库操作事务的四大特性

### 7.1 事务操作数据库的四大特性(ACID)

- 原子性 (`Atomicity`):就是事务的所包含的所有操作，要么全部成功，要么全部失败回滚。
- 一致性 (`Consistency`):简单来说就是在事务执行前和执行后，必须保持数据的一致。
- 隔离性 (`Isolation`):一个事务执行的过程当中，不能被其他的事务干扰。比如有事务A和事务B，相对于A来说，B想要执行，要么在我执行之前执行，要么在我执行完毕之后，你再开始执行.

- 持久性 (`Durability`):事务被提交之后，他就被永久的存储到了数据库当中.

### 7.2 不考虑事务的隔离性所引发的问题

- **脏读:** 一个事务读取到了一个未提交的事务的数据。
- **不可重复读:** 一个事务读取了另一个已经提交了的事务的数据。

- **虚读(幻读)**: 出现幻读不是对一条数据的操作而产生的问题，而是操作多条数据产生的问题，例如：事务A想要对一张表中的某一字段的值进行修改，假设有一个字段的值全部为1，事务A现在想要将1全部修改为2，在提交事务之后，事务B接着又进行了一个操作，在这张表中添加了一个字段，值全部为1。那么这时候操作事务A的用户在查看的时候，会发现还有一行数据没有进行修改，其实这是事务B在他查看之前添加的。



## 8. 事务的四种隔离级别

### 8.1 级别分类

- `Serializable `(序列化)：可避免脏读、不可重读读、幻读的发生
- `Repeatable-read` (可重复读)：可避免脏读、不可重复读的发生。
- `Read-committed` (读已提交)：可避免脏读的发生。
- `Read-uncommitted` (读未提交)：最低级别，任何情况都无法保证。
>以上四种的隔离级别最高的Serializable，最低的是Read uncommitted，级别越高，虽然安全级别越高，但是执行的效率就越低，MySQL中默认的隔离级别是:Repeatable read(可重复读)，oracle默认的隔离级别是：Read committed(读已提交)。

> <font color='red'>这里需要注意的是，mysql支持以上四种隔离级别，但是oracle只支持Serializable(串行化)和Read committed(读已提交)这两种隔离级别。</font>

### 8.2 查看当前事务隔离级别

```mysql
select @@tx_isolation
```

### 8.3 设置mysql的隔离级别

```mysql
set tx_isolation='read-uncommitted'
```

><font color='red'>记住:设置数据库的隔离级别一定要是在开启事务之前！</font>

> 隔离级别的设置只对当前的链接有效。对于MySQL窗口来说，一个窗口就是一个链接，当前设置的事务隔离级别只对当前的窗口有效。



## 9. 索引类型

### 9.1 普通索引(index):

```bash
# 创建:
CREATE INDEX <索引名> ON tablename (索引字段)
# 修改:
ALTER TABLE tablename ADD INDEX [索引名] (索引字段)
# 创表指定索引:
CREATE TABLE tablename([...],INDEX[索引名](索引字段))
```

### 9.2 唯一索引(unique):
<font color='red'>在普通索引的基础上，会进行排除重复值</font>

```bash
# 创建:
CREATE UNIQUE <索引名> ON tablename (索引字段)
# 修改:
ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段)
# 创表指定索引:
CREATE TABLE tablename([...],UNIQUE[索引名](索引字段)) 
```

### 9.3 主键(primary key):
<font color='red'>和唯一索引的区别在于一个表里只能有一个主键索引，但是唯一索引可以有多个</font>

```bash
# 它是唯一索引,一般在创建表是建立,语法：
 CREATA TABLE tablename ([...],PRIMARY KEY[索引字段])
```

### 9.4 联合索引:

```bash
# 语法：
ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 )
```

### 9.5 全文索引 (fulltext)

> MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
>
> MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;
>
> 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

**1.创建全文索引**

```bash
# 创建表时创建全文索引
CREATE TABLE `user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `phone` char(11) NOT NULL DEFAULT '' COMMENT '手机号',
  `name` varchar(30) NOT NULL DEFAULT '' COMMENT '用户名',
  `address` text NOT NULL COMMENT '地址',
  PRIMARY KEY (`id`),
  FULLTEXT KEY address_fulltext(address) # 创建全文索引列
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4  COMMENT='用户帐号表';

# 在已存在的表上创建全文索引
CREATE fulltext index name_fulltext on `user`(address); 

# 通过SQL语句 ALTER TABLE 创建全文索引
alter table `user` add FULLTEXT index name_fulltext(address);
```

**2.使用全文索引**
和常用的模糊匹配使用 `like + %` 不同，全文索引有自己的语法格式，使用 `match `和 `against `关键字，比如

```bash
SELECT * from `user` WHERE MATCH(`address`) against('碧园春小区')
```

> match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。



## 10. 超键、候选键、主键、外键

- 主键(Primary Key)：对数据库表中的每一行数据进行唯一标识,使用`PRIMARY KEY`进行标识。

- 外键(foreign key)：是表中的一列，其值必须在另一个表的主键中。
- 超键(Super Key)：在关系中能惟一标识元组(数据库中的一条记录)的属性集称为关系模式的超键。 

>比如一张学生信息表，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。

- 候选键(Candidate Key)：不含有多余属性的超键称为候选键。也就是在候选键中，若要再删除属性，就不能唯一标识元组了。

> 如：学生表中的候选键为：（学号）、（身份证号）。



## 11. BTREE索引和HASH索引的区别

- Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询（查询范围时 慢）

- Hash 索引无法被用来避免数据的排序操作。

  > 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

- Hash 索引不能利用联合索引(最左原则)。
- Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高



## 12. BLOB和TEXT有什么区别

- 二者之间的主要差别是 BLOB 能用来保存二进制数据（比如照片），而TEXT只能保存字符数据
- TEXT值是大小写不敏感的
- BLOB值进行排序和比较时区分大小写

## 13. 什么是存储过程？

存储过程是一些预编译的SQL语句。

1. 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
2. 存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全。

## 14. 数据库的乐观锁和悲观锁是什么？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- **悲观锁:** 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- **乐观锁:** 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。



## 15. int(10)和char(10)和varchar(10)的区别？

int(10)中的10表示的是显示数据的长度，而char(10)和varchar(10)表示的是存储数据的大小。

## 16. 慢查询相关

慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志

### 16.1 相关参数

- slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。
- slow_query_log_file：MySQL数据库慢查询日志存储路径。
- long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。
- log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。
- log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。

### 16.2 如何对慢查询进行优化？

- 分析语句的执行计划，查看SQL语句的索引是否命中
- 优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。
- 优化LIMIT分页,**在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询**。



## 17. 主键用自增ID还是UUID？

### 17.1 自增ID优缺点

#### 1. 优点 

- 字段长度较uuid会小很多。
- 数据库自动编号，按顺序存放，利于检索
- 无需担心主键重复问题

#### 2.缺点

- 因为是自增，在某些业务场景下，容易被其他人查到业务量。
- 发生数据迁移时，或者表合并时会非常麻烦
- 在高并发的场景下，竞争自增锁会降低数据库的吞吐能力

### 17.2 UUID优缺点

> 通用唯一标识码，UUID是基于当前时间、计数器和硬件标识等数据计算生成的。

#### 1. 优点

- 唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。
- 可以在应用层生成，提高数据库的吞吐能力。
- 无需担心业务量泄露的问题。

#### 2. 缺点

- 因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。
- UUID占用空间较大，建立的索引越多，造成的影响越大。
- UUID之间比较大小较自增ID慢不少，影响查询速度。

### 17.3 总结

> 一般情况`MySQL`推荐使用自增ID。因为在MySQL的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可，如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降。



## 18.字段为什么要设置成not null?

首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。

字段设置成not null主要有以下几点原因：

- NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。
- B树不存储NULL，所以索引用不到NULL，会使索引失效，引起全表扫描。
- NOT IN子查询在有NULL值的情况下返回的结果都是空值。
- MySQL在进行比较的时候，NULL会参与字段的比较，会引起全表扫描。



## 19. 如何优化WHERE子句？

- 避免在 where 子句中使用!=或<>操作符。
- 在where及order by涉及的列上建立索引。
- 避免在 where子句中对字段进行null值判断。

``` sql
如：select id from test where num is null
```

> <font color='red'>因此字段都应设置为NOT NULL，将来查询的时候就不用去比较NULL值</font>

- 避免在where子句中使用or来连接条件。
 ```sql
 -- 错误示例
 select id from t where num=10 or num=20
 -- 正确示例
 select id from t where num=10 union all select id from t where num=20
 ```
- in 和 not in 也要慎用
- 避免在 where 子句中对字段进行表达式操作

```sql
-- 错误示例
select id from t where num/2=100
-- 正确示例
select id from t where num =100*2
```

- 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，一个表的索引数最好不要超过6个。

- 任何地方都不要使用 `select * from t `，用具体的字段列表代替`*`，不要返回用不到的任何字段。

## 20. 大表如何优化？

- 限定数据的范围：避免不带任何限制数据范围条件的查询语句。
- 读写分离：主库负责写，从库负责读。
- 垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。
- 水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。
- 对单表进行优化：对表中的字段、索引、查询SQL进行优化。
- 添加缓存

## 21 . 垂直分表、垂直分库、水平分表、水平分库

### 1. 垂直拆分

#### 1.1 垂直分表(按列)

将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中

**垂直分表的优势：**

- 避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。
- 可以更好地提升热门数据的查询效率。

#### 1.2 垂直分库

按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。

垂直分库的优势：

- 降低业务中的耦合，方便对不同的业务进行分级管理。
- 可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。

#### 1.3 垂直拆分缺点

- 主键出现冗余，需要管理冗余列
- 事务的处理变得复杂
- 仍然存在单表数据量过大的问题

## 2. 水平拆分

####  2.1 水平分表(按行)

在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。

**水平分表的优势：**

- 解决了单表数据量过大的问题
- 避免IO竞争并减少锁表的概率

#### 2.2 水平分库

把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上。

**水平分库的优势：**

- 解决了单库大数据量的瓶颈问题
- IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳定性和可用性

#### 2.3  水平拆分缺点

- 分片事务一致性难以解决
- 跨节点JOIN性能差，逻辑会变得复杂
- 数据扩展难度大，不易维护



## 22. 分库分表后，ID键如何处理？

分库分表后不能每个表的ID都是从1开始，所以需要一个全局ID，设置全局ID主要有以下几种方法：

- **UUID：** 优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合作为索引。
- **数据库自增ID:**在分库分表表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈。
- **Redis生成ID：** 优点：不依赖数据库，性能比较好。缺点：会使得系统复杂度增加。
- `Twitter`的`snowflake(雪花)`算法
  ![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/image-20210911130422049.png)

- 美团的Leaf分布式ID生成系统.



## 23. MySQL的复制原理及流程(如何实现主从复制)？

为保证主服务器和从服务器的数据一致性，在向主服务器插入数据后，从服务器会自动将主服务器中修改的数据同步过来。

### 1. 复制原理

主从复制主要有三个线程：binlog线程，I/O线程，SQL线程。

- binlog线程：负责将主服务器上的数据更改写入到二进制日志（Binary log）中。
- I/O线程：负责从主服务器上读取二进制日志（Binary log），并写入从服务器的中继日志（Relay log）中。
- SQL线程：负责读取中继日志，解析出主服务器中已经执行的数据更改并在从服务器中重放。

### 2. 复制流程

![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/v2-888a92729caa14a01a1cb231dd039e18_1440w.jpg)

1. Master在每个事务更新数据完成之前，将操作记录写入到binlog中。
2. Slave从库连接Master主库，并且Master有多少个Slave就会创建多少个`binlog dump`线程。当Master节点的binlog发生变化时，`binlog dump`会通知所有的Slave，并将相应的binlog发送给Slave。
3. I/O线程接收到binlog内容后，将其写入到中继日志（Relay log）中。
4. SQL线程读取中继日志，并在从服务器中重放。

### 3. 主从复制的作用

- 高可用和故障转移
- 负载均衡
- 数据备份



## 24. SQL语句执行的很慢原因是什么

- 如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要将redo log中的数据同步到磁盘中去。
- 如果SQL语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。

## 25 普通索引,唯一索引,主键索引 哪个速度更快？

速度是一样的快，因为三者都是采用btree二叉树算法进行查找。

## 26. Mysql索引什么时候会失效？

- 模糊查询以` "%"`开头索引失效，因为不确定`%` 的值

- 使用 or 的时候会失效，如果使用 or 要求条件两边都要有索引，才会使用索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。

- 使用复合索引的时候，没有使用第一索引列查找

- 最左前缀原则

- 在where当中索引列参加了运算，索引失效

- 在where列中使用了函数

- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引 



## 27. 说一说索引的底层实现

### 1. Hash索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。

![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/bVcSKih.png)

### 2. B-Tree(B树)索引

`B-Tree`能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中

![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/bVcSKii.png)

### 3. B+Tree索引(mysql默认使用)

是`B-Tree`的改进版本，同时也是数据库索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。<font color=red>相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</font>

**B+tree性质：**

- 所有的非叶子节点只存储关键字信息。 

- 所有具体数据都存在叶子结点中。 

- 所有的叶子结点中包含了全部元素的信息。 

- 所有叶子节点之间都有一个链指针

  

![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/bVcSKij.png)

## 28.为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？

### 1. B+Tree和B-Tree比较

-  **B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域(存放数据)**
-  **B+树所有叶子节点之间都有一个链指针。** 这样遍历叶子节点就能获得全部数据，所以B+树更加适合在`区间查询`的情况。

### 2. Hash

- 虽然可以快速定位，但是没有顺序，IO复杂度高；
- 适合**等值查询**，如=、in()、<=>，不支持范围查询 ；
- 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。

### 3. 二叉树

树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

### 4. 红黑树

树的高度随着数据量增加而增加，IO代价高。



## 29. 讲一讲聚簇索引与非聚簇索引

- 聚簇索引:索引和数据存储在一起,而非聚簇索引，索引和数据存储是分开的

- 对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为**回表**。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。
- 通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可

> 注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。



## 30. 谈一谈 MVCC

### 1. 什么是 MVCC

MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

> <font color=red>@注意: 使用mvcc的前提</font>
>
> - **MVCC**只在 **读已提交(RC)** 和 **可重复读（RR）** 这两种事务隔离级别下才有效，
>
> - 是 **数据库引擎（InnoDB）** 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能

### 2. MVCC 的实现原理

对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：

- ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。
- 事务 ID：记录最后一次修改该记录的事务 ID。
- 回滚指针：指向这条记录的上一个版本。



![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/modb_95751916-225c-11eb-b0bb-5254001c05fe.png)

如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：

- 数据库会先对满足 a=1 的行加排他锁；
- 然后将原记录复制到 undo 表空间中；
- 修改 b 字段的值为 666，修改事务 ID 为 2；
- 并通过隐藏的回滚指针指向 undo log 中的历史记录；
- 事务提交，释放前面对满足 a=1 的行所加的排他锁。

**总结:**

InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。**其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本**。

> MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。

## 31. 大表添加索引

我们需要知道一点，给表添加索引的时候，是会对表加锁的。如果不谨慎操作，有可能出现生产事故的。可以参考以下方法：

- 1.先创建一张跟原表A数据结构相同的新表B。
- 2.在新表B添加需要加上的新索引。
- 3.把原表A数据导到新表B
- 4.rename新表B为原表的表名A，原表A换别的表名；

## 32. 说一说乐观锁和悲观锁

### 1. 概念

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

### 2. 实现方式

**1. 乐观锁-版本号方式：**

- 取出记录时，获取当前`version`
- 更新时，带上这个`version`
- 执行更新时， `set version = newVersion where version = oldVersion`
- 如果`version`不对，就更新失败

**2. 悲观锁：** 通过代码块加锁方式。





## 33. redo log与binlog区别

|          | redo log                                                     | binlog                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件大小 | `redo log `的大小是固定的。                                  | `binlog `可通过配置参数 `max_binlog_size `设置每个` binlog `文件的大小。 |
| 实现方式 | `redo log `是 `InnoDB `引擎层实现的，并不是所有引擎都有。    | `binlog `是 `Server` 层实现的，所有引擎都可以使用 `binlog `日志 |
| 记录方式 | redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。 | binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 适用场景 | `redo log `适用于崩溃恢复(crash-safe)                        | `binlog `适用于主从复制和数据恢复                            |



## 34.  Redis和Mysql的一致性解决方案

### 1. 双删+过期策略

- 先删除缓存；
- 再写数据库；
- 休眠500毫秒；
- 再次删除缓存。