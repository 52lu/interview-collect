## 1.`Redis`与`memcached`的区别与比较

- `Redis`不仅仅支持简单的k/v类型的数据，同时还提供`list，set，zset，hash`等数据结构的存储。`memcache`支持简单的数据类型，String。
- `Redis`支持数据的备份，即`master-slave`模式的数据备份。
- `Redis`支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。
- `Redis`的速度比`memcached`快很多
- `memcached`是多线程，非阻塞IO复用的网络模型；`Redis`使用单线程的IO复用模型。

## 2.使用`Redis`有哪些好处？
- **速度快:**，因为数据存在内存中，类似于`HashMap`，`HashMap`的优势就是查找和操作的时间复杂度都是O(1)
- **支持丰富数据类型:**基本类型：`string，list，set， zset，hash`;特殊类型:`HyperLogLogs（基数统计）， Bitmaps (位图) 和geospatial （地理位置）`
- **支持事务:** `Redis`对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。
- **丰富的特性:** 可用于缓存，消息，按key设置过期时间，过期后将会自动删除

## 3.`Redis`为什么是单线程的？

### 3.1 官方答案

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。单线程无法发挥多核CPU性能，不过可以通过在单机开多个`Redis`实例来解决。

## 4.`Redis`单点吞吐量

单点TPS达到8万/秒，QPS达到10万/秒，补充下TPS和QPS的概念

- **QPS(应用系统每秒钟最大能接受的用户访问量):** 每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。

- **TPS(每秒钟最大能处理的请求数):** 每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。


## 5.`Redis`有哪几种数据淘汰策略？

在`Redis`中，允许用户设置最大使用内存大小server.maxmemory，当`Redis` 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。淘汰策略如下几种:

1. volatile-lru: 从已设置过期的数据中挑选最近最少使用的淘汰

2. volatile-ttl: 从已设置过期的数据集中挑选将要过期的数据淘汰

3. volatile-random: 从已设置过期的数据集中任意挑选数据淘汰

4. allkeys-lru: 从数据集中挑选最近最少使用的数据淘汰

5. allkeys-random: 从数据集中任意挑选数据淘汰

6. noenviction: 禁止淘汰数据

`Redis`淘汰数据时还会同步到aof

## 6.`Redis`的并发竞争问题如何解决?
`Redis`为单进程单线程模式，采用队列模式将并发访问变为串行访问。`Redis`本身没有锁的概念，`Redis`对于多个客户端连接并不存在竞争，但是在Jedis客户端对`Redis`进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：
- 1.客户端角度，为保证每个客户端间正常有序与`Redis`进行通信，对连接进行池化，同时对客户端读写`Redis`操作采用内部锁synchronized。

- 2.服务器角度，利用setnx实现锁。

>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到`Redis`的setnx命令，但是需要注意一些问题。


## 7.`Redis`常见性能问题和解决方案:

1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库



## 8.`Redis`大量数据插入

### 1. netcat

例如，如果我们需要生成一个10亿的`keyN -> ValueN`的大数据集，我们会创建一个如下的`Redis`命令集的文件(data.txt)：

```
SET Key0 Value0
SET Key1 Value1
...
SET KeyN ValueN
```
一旦创建了这个文件，其余的就是让`Redis`尽可能快的执行。在以前我们会用如下的netcat命令执行：
```
(cat data.txt; sleep 10) | nc localhost 6379 > /dev/null
```
### 2. 使用pipe

使用`netcat`并不是一个非常可靠的方式，因为用netcat进行大规模插入时不能检查错误。从`Redis` 2.6开始`redis-cli`支持一种新的被称之为`pipe mode`的新模式用于执行大量数据插入工作。
使用pipe mode模式的执行命令如下：

```
cat data.txt | redis-cli --pipe
```
输出如下信息：
```
All data transferred. Waiting for the last reply...
Last reply received from server.
errors: 0, replies: 1000000
```

**pipe mode的工作原理是什么？**
难点是保证`redis-cli`在pipe mode模式下执行和netcat一样快的同时，如何能理解服务器发送的最后一个回复。
这是通过以下方式获得：

- `redis-cli –pipe`试着尽可能快的发送数据到服务器。
- 读取数据的同时，解析它。
- 一旦没有更多的数据输入，它就会发送一个特殊的ECHO命令，后面跟着20个随机的字符。我们相信可以通过匹配回复相同的20个字符是同一个命令的行为。
- 一旦这个特殊命令发出，收到的答复就开始匹配这20个字符，当匹配时，就可以成功退出了。

同时，在分析回复的时候，我们会采用计数器的方法计数，以便在最后能够告诉我们大量插入数据的数据量。

## 9.`Redis`中的管道有什么用？

可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。


## 10.怎么理解`Redis`事务？

- 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
- 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。


## 11.为什么要做`Redis`分区？
分区可以让`Redis`管理更大的内存，`Redis`将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使`Redis`的计算能力通过简单地增加计算机得到成倍提升,`Redis`的网络带宽也会随着计算机和网卡的增加而成倍增长。

## 12.你知道有哪些`Redis`分区实现方案？

- 客户端分区: 就是在客户端就已经决定数据会被存储到哪个`Redis`节点或者从哪个`Redis`节点读取。大多数客户端已经实现了客户端分区。

- 代理分区: 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些`Redis`实例，然后根据`Redis`的响应结果返回给客户端。`Redis`和`memcached`的一种代理实现就是Twemproxy

- 查询路由(Query routing) 的意思是客户端随机地请求任意一个`Redis`实例，然后由`Redis`将请求转发给正确的`Redis`节点。`Redis` Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个`Redis`节点转发到另一个`Redis`节点，而是在客户端的帮助下直接redirected到正确的`Redis`节点

## 13.`Redis`的内存用完了会发生什么？

如果达到设置的上限，`Redis`的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将`Redis`当缓存来使用配置淘汰机制，当`Redis`达到内存上限时会冲刷掉旧的内容。

## 14. `Redis`主从结构方式有哪几种？

**`Redis`设置主从结构有三种方式:**

- 在redis.conf中配置`replicaof <masterip> <masterport>`，如`replicaof 192.168.1.2 6379`将建立与实例`192.168.1.2:6379`的主从关系；这种方式等同于在Redis启动命令中增加参数`replicaof`参数。
- 在redis-server启动参数中增加“--replicaof <masterip> <masterport>”参数。
- 使用redis-cli客户端连接到redis服务，执行`replicaof <masterip> <masterport>`命令。**注意：如果Redis重启，主从关系将无法重新建立**。

> 注意：Redis 5.0之后，replicaof已经替换slaveof，由于一些种族歧视的奇葩要求，Redis已经对指令进行了兼容升级，目前slaveof还是可以使用的。

## 15. 主从复制的作用

-  数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。

- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。

- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。

- 读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；

-  高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## 16. 主从复制原理

#### 1. 过程可分3个阶段

主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。在从节点执行 slaveof 命令后，复制过程便开始运作，下面图示大概可以看到，

![](https://gitee.com/QingHui/picGo-img-bed/raw/master/img/v2-23352a607011dd20a5812856dd06f77f_1440w.jpg)

#### 2. 同步原理

在主从复制模式下，Redis使用一对`Replicaion ID, offset`来唯一识别Master节点数据集的版本，要理解这个“版本“的概念需要认识Redis的以下三个概念：

- Replication ID（复制ID）：每个Redis的主节点都用一个随机生成的字符串来表示在某一时刻其内部存储数据的状态，“某一时刻”可以理解为其成为master角色的那一刻，由源码可知在第一个从节点加入时，Redis初始化了复制ID。
- offset（复制偏移量）：主从模式下，主节点会持续不断的向从节点传播引起数据集更改的命令，offset所表示的是主节点向从节点传递命令字节总数。它不是孤立存在的，需要配合复制积压缓冲区才能工作。
- backlog（复制积压缓冲区）：它是一个环形缓冲区，用来存储主节点向从节点传递的命令，它的大小是固定的，可存储的命令有限，超出部分将会被删除。它即可用于部分同步，也可用于命令传播阶段的命令重推。

**如何工作：**

- 从节点与主节点建立连接后，需要从节点使用命令`PSYNC <replid> <offset>`向主节点发起同步请求，从节点会从`server.cache_master`中取出两个参数构建命令，然后发给主节点。注意：如果该从节点是全新的，从未与任何主节点进行主从复制，那么会使用特殊的命令：`PSYNC ? -1`。
- 主节点接收到命令，解析请求中的复制ID和offset，然后去判断当前请求是否可以使用部分同步。
- 能够使用部分同步需要满足以下两个条件（**这里先不考虑主从切换导致的多复制ID情况**）：
  - 复制ID与主节点的复制ID一致；
  - 复制偏移量offset必须在backlog大小的范围之间；
- 不能使用部分同步，就不得不使用全量同步了。



## 17.`Redis`集群选举原理

#### 1. 了解gossip协议

了解redis集群选举原理之前，我们首先要明白一件事情，那就是redis集群各节点之前的通讯协议：gossip协议。

gossip协议简单来解释下：各节点之间都会保持通讯，当某一个节点挂掉或者新增的时候，与它相邻的节点就会感知到，这时候此节点就是失去链接或者创建链接。

- ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据；
- pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新；
- fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。
- meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信，不需要发送形成网络的所需的所有CLUSTER MEET命令。

#### 2. 选举流程

当slave（从节点）发现自己的master（主节点）不可用时，变尝试进行Failover，以便称为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：

1. slave发现自己的master不可用；
2. slave将记录集群的currentEpoch（选举周期）加1，并广播FAILOVER_AUTH_REQUEST 信息进行选举；
3. 其他节点收到FAILOVER_AUTH_REQUEST信息后，只有其他的master可以进行响应，master收到消息后返回FAILOVER_AUTH_ACK信息，对于同一个Epoch，只能响应一次ack；
4. slave收集maste返回的ack消息
5. slave判断收到的ack消息个数是否大于半数的master个数，若是，则变成新的master；
6. 广播Pong消息通知其他集群节点，自己已经成为新的master。

> 注意：从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。

**延迟计算公式：**

```properties
DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms
```

> SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。

## 18. Redis集群相关问题

#### 1. Redis集群为什么至少需要三个master节点？

因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。

#### 2.Redis集群为什么至少推荐节点数为奇数？

奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是从节省机器资源角度出发说的。

#### 3.网络不稳定是否会是否引起选举？

真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。

为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。



## 19. redis 持久化的两种方式

- RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。
- AOF：AOF 机制对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。








